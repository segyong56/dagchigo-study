작성자: 강주오

# **1. 인증이 필요한 이유?**

- Connectionless 프로토콜(비연결지향)<br>
  -> 클라이언트가 서버에 요청(Request)을 했을 때,그 요청에 맞는 응답(Response)을 보낸 후 연결을 끊는 처리방식
- 웹서버는 HTTP 프로토콜(Stateless)을 사용하기 때문에 사용자의 로그인 여부에 대한 상태가 존재하지 않음
- 하지만 사용자가 매번 웹페이지의 서비스를 사용할때 매번 로그인 요청을 할순 없음
- 따라서 사용자가 로그인 한 회원인지 아닌지 관리하지 위해 인증을 사용함

---

# **2. Session, Cookie**

## **1. Session**

- 일정 시간동안 같은 브라우저로 부터 들어오는 일련의 요청을 하나의 상태로 보고, 그 상태를 유지하는것
- 방문자가 웹서버에 접속한 상태를 하나의 단위로 보고 세션이라고 한다.

## **2. Cookie**

- 서버에서 클라이언트에 데이터를 저장하는 방법의 하나
- 상태 정보를 유지하는 기술

## **3. Session VS Cookie**

|         |                                           설명                                            | 상태저장 경로 |          장점          |                               단점                                |
| :-----: | :---------------------------------------------------------------------------------------: | :-----------: | :--------------------: | :---------------------------------------------------------------: |
| Cookie  |                                 stateless를 보완하기 위함                                 |  클라이언트   |  서버에 부담을 덜어줌  |                    쿠키자체는 인증방법이 아님                     |
| Session | 상태를 서버가 가지고있음(stateful)<br>접속상태와 권한부여를 위해 세션아이디를 쿠키로 전송 |     서버      | 서버에서 유저확인 가능 | 서버에서 모든 상태를 가지고 있음<br>사용자가 많으면 관리가 어려움 |

## **4. 동작 방식**

1. 사용자가 로그인 요청, 요청이 유효(id, psw 일치)하면 세션이 서버의 메모리,session store에 저장됨<br>-> 세션 식별키로 sessionId를 기준으로 정보저장
2. 서버에서 클라이언트로 쿠키에 sessionId를 cookie에 담아 클라이언트에 전달
3. 브라우저는 서비스 사용시 모든 요청에 cookie(sessionId)를 전송
4. 서버는 클라이언트가 보낸 sessionId를 키로 서버 메모리,session store에서 사용자의 session정보 식별<br>-> 유효하다면, 요청에 대한 응답

<img src="https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fe753000d-4d5c-488a-98d9-f93cf2888eef%2FUntitled.png&blockId=74953a09-9d29-4d62-9f71-1651571165c7" width="450" height="380">

## **5. Session 특징**

- 서버에서 클라이언트의 상태를 메모리, DB등을 통해 가지고 있음
- 클라이언트의 상태를 서버에서 계속 유지하고 이 정보를 서비스에 이용하는 Stateful 서버

## **6. Cookie 특징**

- 서버가 클라이언트에 데이터를 저장할 수 있다.
- 보안등의 이유로 여러 옵션들이 사용되고 있고 설정에 따라 조건이 맞을 경우에만 쿠키를 가져올수 있음.
- 서버는 클라이언트에 인증정보를 담은 쿠키를 전송하고, 클라이언트는 전달받은 쿠키를 요청과 같이 전송하여<br>Stateless 한 인터넷 연결을 Stateful 하게 유지할 수 있음

## **7. Session 장점**

- 서버에서 상태를 유지하고 있기 때문에 사용자 로그인 여부 확인가능
- 클라이언트가 임의로 정보를 변경해도 서버에서 정보를 관리하므로 상대적으로 안전

## **7. Session 단점**

- 서버에서 클라이언트의 상태를 모두 유지하고 있어야 하므로, 클라이언트 수에 따른 메모리나 디스크 또는 DB에 부하가 심하다.
- 사용자가 많아지는 경우 로드 밸런싱을 사용한 서버 확장을 이용해야 하는데 이 때 세션의 관리가 어려워진다.

---

### ⚙️ Cookie Option

- Domain : 클라이언트 쿠키의 도메인 옵션과 서버의 도메인이 일치해야만 쿠키 전송가능
- Path : 세부경로는 서버라 라우팅할떄 사용하는경로(Default : "/")<br>설정된 Path를 전부 만족하는 경우에만 쿠키 전송가능
- MaxAge, Expires : 쿠키의 유효기간 설정
- Secure : 프로토콜에 따른 쿠키 전송 여부 설정(Default: "false")<br>"true"로 설정 할 경우 HTTPS 프로토콜에서만 전송가능
- Samesite: Cross-Origin 요청을 받은 경우 메소드와 옵션의 조합으로 쿠키 전송여부 결정<br>
  Lax: Cross-Origin 요청이면 'GET' 메소드에 대해서만 쿠키 전송<br>
  Strict : Cross-Origin이 아닌 same-site(origin, server 도메인일치)인 경우에만 쿠키 전송<br>
  None: 항상 쿠키를 전송가능. 쿠키 옵션 중 Secure 옵션 필요

---

# **3. 토큰 기반 인증이란?**

- 인증 받은 사용자들에게 토큰을 발급, 서버에 요청 할 때 토큰을 함께 보내 유효성 검사를한다.
- 사용자의 인증정보를 서버나 세션에 유지하지 않고 클라이언트 측에서 들어오는 요청만으로 작업을 처리함
- 서버기반의 인증시스템과 달리 Stateless한 구조를 가짐
- 트래픽을 감당하기 위하여 여러개의 프로세스를 돌리거나 여러대의 서버 컴퓨터를 추가하지 않아도되기 떄문에 확장성이 높음

---

## **1. 인증과정**

1. 사용자 로그인 요청
2. 서버 -> 회원 확인
3. 계정정보가 정확하다면 유저에게 Access(+Refresh) Token 발급<br>
   -> 토큰에는 유효기간을 설정해야하며, 인증에 필요한 정보를 암호화하여 토큰발급(JWT)
4. 로그인 요청에 대한 응답과 함께 토큰을 클라이언트에게 보냅니다.
5. 클라이언트 측에서는 토큰을 저장해두고 서버에게 요청할 때 함께 전송
6. 서버는 해당 토큰을 복호화한후 유효한 토큰인지 검증
7. 검증에 성공하면, 해당 사용자에 맞는 데이터 응답
8. 토큰만료(검증실패)시 클라이언트에 실패응답 및 Refresh Token 요청
9. Refresh Token 검증후<br>
   만료: 클라이언트에 실패 및 재로그인 요청 응답<br>
   유효: Access Token 재발급후 클라이언트에 전달

<img src="https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F6bc2e007-9893-46e4-9b6b-2c7fa7fbe143%2FUntitled.png&blockId=28eac9a0-3b8e-4cf1-a219-594a943b7ede" width="500" height="400"></img>

---

## **2. 장단점**

### **1. 장점**

1. Stateless 서버<br>
   : 세선/쿠키 인증방식은 서버에서 별도의 세션 저장소에 클라이언트 상태를 계속 유지하고 이 정보를 서비스에 이용하는 Stateful 서버였음. 하지만 토큰에는 인증에 필요한 모든 정보를 담고 있으므로, 서버에 별도의 세션저장소가 필요하지 않으며 서버는 클라이언트측에서 들어오는 요청으로만 작업을 처리

2. 높은 서버 확장성<br>
   : 토큰 기반 인증은 Stateless 서버, 즉 클라이언트와 서버와의 연결고리가 없기때문에 서버의 확장성이 좋아짐. 여기서 말하는 서버의 확장성이란 많은 트래픽을 감당하기 위하여 여러개의 프로세스를 돌리거나 여러대의 서버 컴퓨터를 추가 하는것을 의미함

3. 확장성(Extensibility)<br>
   : 여기서의 확장성은 로그인 분야의 확장되는 것을 의미함. 토큰을 사용하여 다른 서비스에서도 권한을 공유할 수 있음. 대표적인 예제로 OAuth, 이를 통해 페이스북/구글/네이버 계정을 이용하여 다른 웹서비스에 로그인할 수 있음

---

### **2. 단점**

1. 이미 발급된 토큰에대해서는 돌이킬 수 없음.<br>
   : 세션/쿠키 방식에서는 서버가 클라이언트의 세션을 삭제시켜 강제 로그아웃이 가능했지만, 토큰은 한번 발급되게되면 유효기간이 지날때까지 계속 사용이 가능함.<br>
   -> 서버에서 토큰을 제어할 수 없음<br>
   -> Access Token의 유효기간을 짧게하고 Refresh Token이라는 새로운 토큰을 발급하면 해결 가능<br>

---

## **3. Json Web Token(JWT)**

- 토큰 기반 인증 중 가장 많이 사용 되고 있음
- 인증 정보를 담고있는 JSON 객체를 암호화시켜 인증 정보를 안전하게 전송함
- 이떄 암호화는 비밀키(HAMC) 혹은 공개키,개인키쌍(RSA)를 사용

### **1. 구조**

- Header: 토큰의 타입이 JWT라는 것과 어떤 해싱알고리즘(HMAC, RSA)를 사용했는지 담겨있음
- Payload: 사용자의 인증정보가 담겨있음
- Signature: 전자서명, 헤더에서 명시한 해싱을 통해 생성됨

---

### **2. 토큰 저장 위치**

#### **1. LocalStroage**

##### 1. 장점

- CSRF 공격에 안전
- 자동으로 request에 담기는 쿠키와 다르게 js 코드에 의해 헤더에 담기기 떄문에 XSS를 뚫지 않는 이상,<br>
  공격자가 request를 보내기가 어려움

##### 2. 단점

- XSS에 취약함
- 공격자가 localStorage에 접근하는 Js코드 한줄만 주입하면 localStorage를 공격자가 쉽게 드나들 수 있음

#### **2. Cookie**

##### 1. 장점

- XSS 공격으로부터 LocalStroage에 비해 비교적 안전함
- httpOnly 옵션을 통해 js에서 쿠키에 접근자체가 불가능함
- _사용자의 컴퓨터에서 요청을 위조가능하기 때문에 완전히 안전한것은 아님_

##### 2. 단점

- CSRF 공격에 취약하다.
- 자동으로 http request에 담아서 보내기 때문에 공격자가 request url만 안다면,<br>
  사용자가 관련 link를 클릭하도록 유도하여 request를 위조하기 쉬움

---

## **4. Refresh Token**

- 위의 단점들을 보완하기 위해 사용
- Access Token의 유효기간을 짧게 설정하여 일정 시간마다 토큰을 재발급 해줌
- refresh token이 CSRF에 의해 사용된다 하더라도 공격자는 accessToken을 알 수 없음
- 쿠키를 사용하여 XSS를 막고 refresh token 방식을 이용하여 CSRF를 막을 수 있는 방법

---

### 👨‍💻 Session-Cookie, Token 예상 질문

#### 🛠질문에 대한 답변의 보충작업이 필요합니다! 보충 부탁드려요🛠

1. 세션에 대해서 모르는 사람한테 설명하듯 간단하게 설명해 주세요.

- 세션 인증 방식은 서버에서 클라이언트의 상태를 메모리, DB등을 통해 서버에서 계속 유지하고 이 정보를 서비스에 이용하는 방식을 의미합니다.

2. 서버 측에서 쿠키를 저장할때 클라이언트에 어떤 헤더를 통해 전달될까요.

- set-cookie를 통해 서버에서 전달하며, 클라이언트의 헤더에 쿠키헤더로 저장됩니다.

3. 세션과 토큰 중의 각각 장단점을 말씀해주세요.

- 세션: 클라이언트에서 임의로 정보를 변경해도 서버에서 정보를 관리해 상대적으로 안전합니다.<br>
  반면에 메모리, 디스크, DB에 세션정보를 저장해서 클라이언트가 많아지면 부하가 심하고, 서버 확장시 세션관리가 어려워지는 단점이 있습니다<br>
- 토큰: 사용자의 인증정보를 서버나 세션에 유지하지 않고 클라이언트 측에서 들어오는 요청만으로 작업을 처리하기 때문에 <br>
  트래픽을 감당하기 위하여 여러개의 프로세스를 돌리거나 여러대의 서버 컴퓨터를 추가하지 않아도되서 확장성이 높습니다.<br>
  반면, 서버에서 토큰을 제어할 수 없고, 한번 발급되면 계속 사용할수 있다는 단점이있습니다.<br>

4. 토큰에 있는 내용을 암호화 시켜야될 이유는 뭔가요.

- 토큰에는 유저의 인증정보가 들어있기 때문에 암호화시키는편이 안전합니다.

5. 세션스토어는 물리적으로 어디 저장되어있나요.

- 서버의 메모리

6. 만약 서버가 두개로 분산되어있는데, 서버앱의 세션스토어도 분리될텐데 a서버앱을 통해서는 자동로그인이 되는데 b서버앱을 통해서는 자동로그인이 안될수도 있지 않을까요.

- 그런 문제를 방지하기 위해 다중 서버 세션을 이용할시 세션 클러스터링을 통해 각각의 세션에 세션정보를 복제 하는 방법이 있습니다.
- (꼬리질문)세션클러스터링은 뭐죠? → 말한것처럼 의미만 알고 디테일하게 공부 하지 않아서 모르겠다!!!
